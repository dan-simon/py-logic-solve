from z3 import Int, And, Or, PbEq, Solver, is_true
from lib import set_problem, parse_int_grid, at, connected, construct_vars, eq, in_bounds, inds
import time

g = parse_int_grid('''
.....4.4
.6....4.
...8....
..3.2...
...4....
3....C..
.6......
8.......
''')

g = parse_int_grid('''
....4..
8......
2.23..3
.......
3..92.4
......6
..3....
''')

g = parse_int_grid('''
...C....64....9...
.8...6......6...6.
..................
6.....6....4.....9
...6..........6...
...C..........3...
2.....A....4.....6
..................
.6...4......9...9.
...2....49....6...
''')

g = parse_int_grid('''
8.......6.......4
.....A....4......
...2...8....9....
.8.......6....6..
...........2....4
...4.............
.4...E...6.......
.......L...C...8.
...4.........6...
.8...3...8.......
.......8...6...9.
.............3...
6....8...........
..4....8.......4.
....C....2...6...
......2....8.....
C.......6.......A
''')

g = parse_int_grid('''
......8..........
....6....6.......
..C....6.........
2....4....8....C.
...I....A....8...
.6.........4.....
.........4.....C.
.......8.....8...
.....6.....2.....
...3.....4.......
.9.....A.........
.....C.........8.
...C....6....6...
.C....6....C....8
.........6....6..
.......6....5....
..........8......
''')

g = parse_int_grid('''
...?......
5.........
.......?..
....1.....
.?........
........?.
.....2....
..?.......
.........?
......?...
''', {'?': -1})

g = parse_int_grid('''
...9.....8.......
..............6..
.....5...........
...........K.....
.K.....P........E
.................
....C.........I..
..........C......
.................
......A..........
..U.........I....
.................
G........A.....G.
.....C...........
...........6.....
..8..............
.......6.....8...
''')

height = len(g)
width = len(g[0])
set_problem(g)
tm = time.time()

# This gets the options for a rectangle of size n with cell ind and list of clues clues (where ind is in clues
# and the rectangle can't contain any other clues). It helps a lot when there are no ? clues (for ? clues it's harder to do).
def rect_options(ind, n, clues):
    # Possible height/width pairs
    hw_pairs = [(h, n // h) for h in range(1, n + 1) if n % h == 0]
    # Possible rectangles with given height/width and with clue
    r = [[(ind[0] + i2 - i, ind[1] + j2 - j) for i2 in range(h) for j2 in range(w)]
    for (h, w) in hw_pairs for i in range(h) for j in range(w)]
    # Check rectangles are in bounds and don't have another clue
    return [i for i in r if all(in_bounds(j) for j in i) and len(set(clues) & set(i)) == 1]

cons = []

# Find the clues
clues = [i for i in inds() if at(g, i) != None]

# Do standard connecteness of each region, except that all the regions have a clue and are rectangles.
reg_roots = construct_vars(Int, 'r', (height, width))

cons += connected(reg_roots, (lambda x: True),
(lambda x: at(g, x) != None and eq(at(reg_roots, x), clues.index(x))), 'c', rect=True)[0]

# Check that certain regions are the right size
cons += [PbEq([(eq(at(reg_roots, j), clues.index(i)), 1) for j in inds()],
at(g, i)) for i in inds() if at(g, i) not in (None, -1)]

# Check that values at clues are correct
cons += [at(reg_roots, i) == ind for (ind, i) in enumerate(clues)]

# Check that non-? clues *contain* one of the legal rectangle options.
# This is implied by other constraints, but is very slow to derive from them.
# (Requiring them to be exactly one of those options
# is too slow, because then you have to include all the cells in each constraint,
# dramatically increasing setup time.)
cons += [Or(*[And(*[at(reg_roots, k) == ind for k in j]) for j in rect_options(i, at(g, i), clues)])
for (ind, i) in enumerate(clues) if at(g, i) != -1]

t0 = time.time()
print('constructed', t0 - tm)
s = Solver()
s.add(*cons)
print(s.check())
print('done', time.time() - t0)
m = s.model()
print('\n'.join(''.join(chr(ord('A') + m[j].as_long()) for j in i) for i in reg_roots))
